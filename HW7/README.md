本題在解讀老師提供的 JavaScript 程式碼時，我使用 ChatGPT 協助分析搜尋邏輯，進而確認老師採用的是 BFS（廣度優先搜尋）。BFS 的主要特點是逐層擴展所有可能的狀態，因此能夠保證找到的是「最短解」。在理解這項概念後，我依據老師程式中的核心邏輯，以 Python 重新實作了 BFS 版本。本 Python 實作保留 BFS 的搜尋策略，同樣使用 佇列（queue） 與 訪問記錄（visited），並加入 parent 字典回溯結構 來還原路徑，使程式結構更清晰，也更容易維護。

此外，在 ChatGPT 的講解下，我也進一步理解了另一種搜尋方式——DFS（深度優先搜尋）。DFS 的特點是以深度為優先方向進行探索：會沿著某條路徑一直往下走，直到無法前進時再回溯到前一層並嘗試其他路徑。依據這些特性，我也在 ChatGPT 的協助下完成了 DFS 版本的實作。

在 BFS 的 Python程式中，我將各項功能模組化：

   1.is_safe()用於檢查狀態是否合法

   2.get_neighbors()用於產生所有合法的下一步狀態

   3.parent字典用於在找到目標後進行路徑回溯

在 DFS 程式中，我同樣將功能模組化：

   1.is_safe()與 BFS 版本共用，用來檢查是否安全。

   2.get_neighbors()也共用，用來取得所有可能的下一步行動。

   3.dfs()遞迴函式：

        A.遞迴深入某條狀態路徑

        B.若遇到不合法或已拜訪過的狀態則跳過

        C.若走到死路則使用 path.pop()回溯

   4.visited 集合：避免 DFS 進入無限循環。

   5.path 列表：記錄從起點到目前的探索路徑，用於 DFS 完成後直接輸出結果。
